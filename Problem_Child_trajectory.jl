function Problem_Child_trajectory(F_up, F_down, x0, best_u, dyn, T, Xi)
"""
Output description
Among all (one for each scenario) optimal trajectory for the lower
approximations, gives the one that maximises that gap between upper and lower
approximations.
For now, it is assumed that the upper approximations are generated by a
MinPlus algorithm. The lower approximations are generated by SDDP.

(Some) Input description

best_u, Array of length T-1, each component is a vector containing the best
control to apply at the optimal state (computed in the backward phase) for the
lower approximations
"""
    traj = zeros(Float64, length(x0), T);
    traj[:,1] = x0;
    for t in 1:(T-1)
        currentGap = 0.0;
        for w in 1:length(best_u[t])
            futurState = dyn[t][1]*traj[:,t] + dyn[t][2]*best_u[t][w]
                + dyn[t][3]*Xi[w];
            if Eval_Minplus(t+1, F_up, futurState) -
                Eval_SDDP(t+1, F_down, futurState) > currentGap
                traj[:,t+1] = futurState;
            end
        end
    end
end
